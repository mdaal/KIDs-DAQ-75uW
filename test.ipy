if 0:
	import Instruments
	reload(Instruments)
	na = Instruments.network_analyzer('TCPIP0::169.229.225.4::inst0::INSTR')
	#psu = Instruments.power_supply('GPIB0::14::INSTR')
	#syn =  Instruments.synthesizer('GPIB0::7::INSTR')
	#ADC = Instruments.fridge_ADC('GPIB1::14::INSTR')
	#DAC = Instruments.fridge_DAC('GPIB1::17::INSTR')

if 1:
	import Measurement_Managers
	reload(Measurement_Managers)
	import Instruments
	reload(Instruments)
	import Fridge_Interfaces
	reload(Fridge_Interfaces)
	devices = [('RuOx2','MF2'), ('Ge3', 'MF1'),('Ge4', 'MF3'), ('Stack_Heater_1','Stack_Heater'), ('Helmholtz_Coil', 'Aux')]
	mm = Measurement_Managers.measurement_manager(devices, 'Run53ab')



if 0:
	import Instruments
	reload(Instruments)
	import Fridge_Interfaces
	reload(Fridge_Interfaces)
	#fi = Fridge_Interfaces.fridge_interface([('U03746','MF2'), ('U30593', 'MF1'),('U30817', 'MF3')])
	fi = Fridge_Interfaces.fridge_interface([('RuOx2','MF2'), ('Ge3', 'MF1'),('Ge4', 'MF3'), ('Stack_Heater_1','Stack_Heater'), ('Helmholtz_Coil', 'Aux')])
	
if 0:
	import visa
	import numpy as np
	rm = visa.ResourceManager()
	ADC  = rm.open_resource('GPIB1::14::INSTR', open_timeout=0)
	ADC.chunk_size = 2**15 
	ADC.values_format.is_binary = True 
	ADC.values_format.is_big_endian = True 
	ADC.values_format.container = np.array
	num_readings = 50
	def ADC_Acq(num_readings):
		ADC.write('B-OX')
		ADC.clear()
		ADC.write('A0C5R0I0N0,{}L0T1G9X'.format(num_readings))
		ADC.assert_trigger()
		ADC.write('B-OX')
		#ADC.wait_for_srq()

	# def parse_binary(bytes_data, is_big_endian=False, is_single=False):
	#     """Parse ascii data and return an iterable of numbers.
	#     To be deprecated in 1.7
	#     :param bytes_data: data to be parsed.
	#     :param is_big_endian: boolean indicating the endianness.
	#     :param is_single: boolean indicating the type (if not is double)
	#     :return:
	#     """
	#     data = bytes_data

	#     hash_sign_position = bytes_data.find(b"#")
	#     if hash_sign_position == -1:
	#         raise ValueError('Could not find valid hash position')

	#     if hash_sign_position > 0:
	#         data = data[hash_sign_position:]

	#     data_1 = data[1:2].decode('ascii')

	#     if data_1.isdigit() and int(data_1) > 0:
	#         number_of_digits = int(data_1)
	#         # I store data and data_length in two separate variables in case
	#         # that data is too short.  FixMe: Maybe I should raise an error if
	#         # it's too long and the trailing part is not just CR/LF.
	#         data_length = int(data[2:2 + number_of_digits])
	#         data = data[2 + number_of_digits:2 + number_of_digits + data_length]
	#     else:
	#         data = data[2:]
	#         if data[-1:].decode('ascii') == "\n":
	#             data = data[:-1]
	#         data_length = len(data)

	#     if is_big_endian:
	#         endianess = ">"
	#     else:
	#         endianess = "<"

	#     try:
	#         if is_single:
	#             fmt = endianess + str(data_length // 4) + 'f'
	#         else:
	#             fmt = endianess + str(data_length // 8) + 'd'

	#         result = list(struct.unpack(fmt, data))
	#     except struct.error:
	#         raise ValueError("Binary data itself was malformed")

	#     return result